{
  "FastAPI Minimal Server": {
    "prefix": "fastapi-server",
    "body": [
      "from fastapi import FastAPI",
      "from fastapi.middleware.cors import CORSMiddleware",
      "",
      "ALLOWED_ORIGINS = [",
      "    \"https://localhost:8443\",",
      "]",
      "app = FastAPI()",
      "",
      "app.add_middleware(",
      "    CORSMiddleware,",
      "    allow_origins=ALLOWED_ORIGINS,",
      "    allow_credentials=True, ",
      "    allow_methods=[\"*\"]",
      "    allow_headers=[\"*\"]",
      ")",
      "",
      "@app.get(\"/\")",
      "async def root():",
      "    return {\"message\": \"Hello World\"}",
      "",
      "if __name__ == \"__main__\":",
      "    import uvicorn",
      "    uvicorn.run(app, host=\"0.0.0.0\", port=8000)"
    ],
    "description": "FastAPI minimal server with uvicorn"
  },
  "FastAPI WebSocket Connection": {
    "prefix": "fastapi-websocket-connection",
    "body": [
      "from fastapi import FastAPI, WebSocket",
      "",
      "@app.websocket(\"/ws\")",
      "async def websocket_endpoint(websocket: WebSocket):",
      "    await websocket.accept()",
      "    while True:",
      "        data = await websocket.receive_text()",
      "        print(data)",
      "        await websocket.send_text(f\"Message received: {data}\")",
      ""
    ],
    "description": "FastAPI WebSocket connection"
  },
  "SqlAlchemy Async Session": {
    "prefix": "sqlalchemy-async-session",
    "body": [
      "\"\"\"",
      "Database connection and session management.",
      "",
      "This module provides database connection and session management functionality.",
      "It uses SQLAlchemy's async features to provide async database access.",
      "\"\"\"",
      "",
      "from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession",
      "from sqlalchemy.orm import sessionmaker, declarative_base",
      "from . import settings",
      "",
      "# Create the database URL",
      "SQLALCHEMY_DATABASE_URL = settings.DATABASE_URL.replace('postgresql://', 'postgresql+asyncpg://')",
      "",
      "# Create the async engine",
      "engine = create_async_engine(",
      "    SQLALCHEMY_DATABASE_URL, ",
      "    echo=settings.DB_ECHO,",
      "    pool_size=settings.DB_POOL_SIZE,",
      "    max_overflow=settings.DB_MAX_OVERFLOW,",
      "    pool_timeout=settings.DB_POOL_TIMEOUT,",
      "    pool_recycle=settings.DB_POOL_RECYCLE",
      ")",
      "",
      "# Create the declarative base",
      "Base = declarative_base()",
      "",
      "# Create async session factory",
      "AsyncSessionLocal = sessionmaker(",
      "    engine, ",
      "    class_=AsyncSession, ",
      "    expire_on_commit=False,",
      "    autocommit=False,",
      "    autoflush=False",
      ")",
      "# Dependency for FastAPI",
      "async def get_db():",
      "    \"\"\"",
      "    Get a database session.",
      "    This function is designed to be used as a FastAPI dependency.",
      "    It yields a database session and ensures it is closed after use.",
      "    ",
      "    Yields:",
      "        AsyncSession: A database session",
      "    \"\"\"",
      "    async with AsyncSessionLocal() as session:",
      "        try:",
      "            yield session",
      "        finally:",
      "            await session.close()",
      "",
      "# Function to create all tables",
      "async def create_tables():",
      "    \"\"\"",
      "    Create all tables in the database.",
      "    ",
      "    This function is designed to be called during application startup.",
      "    \"\"\"",
      "    async with engine.begin() as conn:",
      "        await conn.run_sync(Base.metadata.create_all)",
      "# Function to drop all tables",
      "async def drop_tables():",
      "    \"\"\"",
      "    Drop all tables in the database.",
      "    ",
      "    This function is designed to be called during testing.",
      "    \"\"\"",
      "    async with engine.begin() as conn:",
      "        await conn.run_sync(Base.metadata.drop_all)",
      "",
      "# Function to create all tables",
      "async def create_tables():",
      "    \"\"\"",
      "    Create all tables in the database.",
      "    \"\"\""
    ],
    "description": "SqlAlchemy Generate Async Session"
  },
  "Websocker Dispatcher": {
    "prefix": "websocket-dispatcher",
    "body": [
      "from fastapi import WebSocket, WebSocketDisconnect",
      "from typing import Dict, Any, Callable",
      "import asyncio",
      "import redis.asyncio as redis",
      "import json",
      "from . import settings",
      "",
      "class WSDispatcher:",
      "    def __init__(self):",
      "        self.connections: Dict[str, WebSocket] = {}",
      "        self.handlers: Dict[str, Dict[str, Any]] = {}",
      "        self.redis = redis.from_url(settings.REDIS_URL)",
      "        asyncio.create_task(self.subscribe_redis())",
      "        self._subscribe_task = None",
      "",
      "    async def subscribe_redis(self):",
      "        pubsub = self.redis.pubsub()",
      "        await pubsub.psubscribe(\"global\", \"tenant:*\", \"user:*\")",
      "",
      "        async for message in pubsub.listen():",
      "            if message[\"type\"] == \"pmessage\":",
      "                channel = message[\"channel\"].decode()",
      "                data = json.loads(message[\"data\"])",
      "                await self._broadcast_local(channel, data)",
      "",
      "    def on(self, event_type: str, mode: str = \"sync\", authenticated: bool = False):",
      "        def decorator(func: Callable):",
      "            self.handlers[event_type] = {\"func\": func, \"mode\": mode, \"auth\": authenticated}",
      "            return func",
      "        return decorator",
      "",
      "    async def connect(self, websocket: WebSocket, auth_payload: Dict[str, Any]):",
      "        user_id = auth_payload[\"sub\"]",
      "        tenant_id = auth_payload[\"tenant_id\"]",
      "        connection_id = f\"{tenant_id}:{user_id}\"",
      "        await websocket.accept()",
      "        self.connections[connection_id] = websocket",
      "",
      "        try:",
      "            while True:",
      "                data = await websocket.receive_json()",
      "                await self.route_event(data, websocket, auth_payload)",
      "        except WebSocketDisconnect:",
      "            del self.connections[connection_id]",
      "",
      "    async def route_event(self, data: dict, websocket: WebSocket, auth_payload: dict):",
      "        event_type = data[\"type\"]",
      "        handler_info = self.handlers.get(event_type)",
      "",
      "        if not handler_info:",
      "            print(f\"No handler for event: {event_type}\")",
      "            return",
      "",
      "        if handler_info[\"auth\"] and not auth_payload:",
      "            await websocket.send_json({\"error\": \"Authentication required\"})",
      "            return",
      "",
      "        if handler_info[\"mode\"] == \"sync\":",
      "            await handler_info[\"func\"](websocket, data[\"payload\"], auth_payload)",
      "        else:",
      "            await handler_info[\"func\"](websocket, data[\"payload\"], auth_payload)",
      "    async def broadcast(self, event_type: str, payload: dict, tenant_id: str = None, user_id: str = None):",
      "        message = json.dumps({\"type\": event_type, \"payload\": payload})",
      "        channel = \"global\"",
      "        if user_id:",
      "            channel = f\"user:{user_id}\"",
      "        elif tenant_id:",
      "            channel = f\"tenant:{tenant_id}\"",
      "",
      "        await self.redis.publish(channel, message)",
      "",
      "    async def _broadcast_local(self, channel: str, data: dict):",
      "        for connection_id, websocket in self.connections.items():",
      "            tenant_id, user_id = connection_id.split(\":\")",
      "            if channel == \"global\" or channel == f\"tenant:{tenant_id}\" or channel == f\"user:{user_id}\":",
      "                print(f\"Broadcasting message to {connection_id}: {data}\")",
      "                await websocket.send_json(data)",
      "",
      "# Create a global dispatcher instance",
      "dispatcher = WSDispatcher()"
    ],
    "description": "Websocket Dispatcher"
  },
  "Websoccket Dispatcher Action": {
    "prefix": "websocket-dispatcher-action",
    "body": [
      "from app.core.ws import dispatcher",
      "",
      "@dispatcher.on(\"chat:send\", mode=\"sync\", authenticated=True)",
      "async def chat_send_handler(websocket, payload, auth_payload):",
      "    tenant_id = auth_payload[\"tenant_id\"]",
      "    user_id = auth_payload[\"sub\"]",
      "    message = {\"user\": user_id, \"message\": payload[\"message\"]}",
      "    await dispatcher.broadcast(\"chat:new_message\", message, tenant_id=tenant_id)"
    ],
    "description": "Websocket Dispatcher Action"
  },
  "Logger JSON": {
    "prefix": "logger-json",
    "body": [
      "import logging",
      "import json",
      "import sys",
      "import traceback",
      "from datetime import datetime",
      "from typing import Any, Dict, Optional, Union",
      "from functools import wraps",
      "import inspect",
      "",
      "# Configure the root logger",
      "logging.basicConfig(",
      "    level=logging.INFO,",
      "    format='%(message)s',  # We'll format the message ourselves",
      "    handlers=[logging.StreamHandler(sys.stdout)]",
      ")",
      "",
      "class JSONFormatter(logging.Formatter):",
      "    \"\"\"Custom formatter that outputs JSON structured logs.\"\"\"",
      "    def format(self, record: logging.LogRecord) -> str:",
      "        \"\"\"Format the log record as JSON.\"\"\"",
      "        log_data: Dict[str, Any] = {",
      "            \"timestamp\": datetime.utcnow().isoformat(),",
      "            \"level\": record.levelname,",
      "            \"logger\": record.name,",
      "            \"message\": record.getMessage(),",
      "            \"module\": record.module,",
      "            \"function\": record.funcName,",
      "            \"line\": record.lineno,",
      "        }",
      "",
      "        # Add exception info if present",
      "        if record.exc_info:",
      "            log_data[\"exception\"] = {",
      "                \"type\": record.exc_info[0].__name__,",
      "                \"message\": str(record.exc_info[1]),",
      "                \"traceback\": traceback.format_exception(*record.exc_info)",
      "            }",
      "        # Add extra fields if present",
      "        if hasattr(record, \"extra\"):",
      "            log_data.update(record.extra)",
      "",
      "        return json.dumps(log_data)",
      "",
      "def get_logger(name: Optional[str] = None) -> logging.Logger:",
      "    \"\"\"Get a logger with JSON formatting.\"\"\"",
      "    if name is None:",
      "        # Get the name of the calling module",
      "        frame = inspect.currentframe()",
      "        if frame and frame.f_back:",
      "            name = frame.f_back.f_globals.get(\"__name__\", \"unknown\")",
      "",
      "    logger = logging.getLogger(name)",
      "",
      "    # Only add the handler if it doesn't already have one",
      "    if not logger.handlers:",
      "        handler = logging.StreamHandler(sys.stdout)",
      "        handler.setFormatter(JSONFormatter())",
      "        logger.addHandler(handler)",
      "",
      "    # Don't propagate to root logger to avoid duplicate logs",
      "    logger.propagate = False",
      "",
      "    return logger",
      "",
      "def get_logger(name: Optional[str] = None) -> logging.Logger:",
      "    \"\"\"",
      "    Get a logger with JSON formatting.",
      "    ",
      "    Args:",
      "        name: The name of the logger. If None, the name of the calling module will be used.",
      "",
      "    Returns:",
      "        A configured logger instance.",
      "    \"\"\"",
      "    if name is None:",
      "        # Get the name of the calling module",
      "        frame = inspect.currentframe()",
      "        if frame and frame.f_back:",
      "            name = frame.f_back.f_globals.get(\"__name__\", \"unknown\")",
      "",
      "    logger = logging.getLogger(name)",
      "",
      "    # Only add the handler if it doesn't already have one",
      "    if not logger.handlers:",
      "        handler = logging.StreamHandler(sys.stdout)",
      "        handler.setFormatter(JSONFormatter())",
      "        logger.addHandler(handler)",
      "",
      "    # Don't propagate to root logger to avoid duplicate logs",
      "    logger.propagate = False",
      "",
      "    return logger",
      "",
      "def log_function_call(logger: Optional[logging.Logger] = None):",
      "    \"\"\"",
      "    Decorator to log function calls with their arguments and return values.",
      "    ",
      "    Returns:",
      "        A decorator function.",
      "    \"\"\"",
      "    def decorator(func):",
      "        @wraps(func)",
      "        async def async_wrapper(*args, **kwargs):",
      "            # Get the logger if not provided",
      "            nonlocal logger",
      "            if logger is None:",
      "                logger = get_logger(func.__module__)",
      "",
      "            # Log the function call",
      "            logger.debug(",
      "                f\"Calling {func.__name__}\",",
      "                extra={",
      "                    \"function\": func.__name__,",
      "                    \"args\": str(args),",
      "                    \"kwargs\": str(kwargs)",
      "                }",
      "            )",
      "",
      "            try:",
      "                # Call the function",
      "                result = await func(*args, **kwargs)",
      "",
      "                # Log the return value",
      "                logger.debug(",
      "                    f\"{func.__name__} returned successfully\",",
      "                    extra={",
      "                        \"function\": func.__name__,",
      "                        \"result\": str(result)",
      "                    }",
      "                )",
      "",
      "                return result",
      "            except Exception as e:",
      "                # Log the exception",
      "                logger.exception(",
      "                    f\"Exception in {func.__name__}\",",
      "                    extra={",
      "                        \"function\": func.__name__,",
      "                        \"exception\": str(e)",
      "                    }",
      "                )",
      "                raise",
      "",
      "        # Return the appropriate wrapper based on whether the function is async",
      "        if inspect.iscoroutinefunction(func):",
      "            return async_wrapper",
      "        else:",
      "            return sync_wrapper",
      "",
      "    return decorator",
      ""
    ],
    "description": "Logger JSON"
  },
  "Security JWT": {
    "prefix": "security-jwt",
    "body": [
      "import jwt",
      "from datetime import datetime, timedelta, timezone",
      "from typing import Optional",
      "from passlib.context import CryptContext",
      "from . import settings",
      "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
      "",
      "ALGORITHM = \"HS256\"",
      "REFRESH_TOKEN_EXPIRE_DAYS = settings.REFRESH_TOKEN_EXPIRE_DAYS",
      "",
      "def create_access_token(user_id: str, tenant_id: str, expires_delta: Optional[timedelta] = None):",
      "    to_encode = {",
      "        \"sub\": user_id,",
      "        \"tenant_id\": tenant_id,",
      "        \"exp\": datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES))",
      "    }",
      "    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=ALGORITHM)",
      "",
      "def decode_token(token: str):",
      "    try:",
      "        return jwt.decode(token, settings.SECRET_KEY, algorithms=[ALGORITHM])",
      "    except jwt.PyJWTError:",
      "        return None",
      "",
      "def hash_password(password: str) -> str:",
      "    return pwd_context.hash(password)",
      "",
      "def verify_password(password: str, hashed_password: str) -> bool:",
      "    return pwd_context.verify(password, hashed_password)",
      ""
    ],
    "description": "Security JWT"
  },
  "SQLAlchemy Base Model": {
    "prefix": "sqlalchemy-base-model",
    "body": [
      "\"\"\"",
      "Base model for SQLAlchemy models.",
      "",
      "This module defines the base model for all SQLAlchemy models.",
      "\"\"\"",
      "",
      "from sqlalchemy.orm import DeclarativeBase",
      "from sqlalchemy.ext.declarative import declared_attr",
      "from sqlalchemy import Column, DateTime",
      "from datetime import datetime",
      "import uuid",
      "",
      "def generate_uuid():",
      "    return str(uuid.uuid4())",
      "",
      "class Base(DeclarativeBase):",
      "    \"\"\"",
      "    Base class for all SQLAlchemy models.",
      "    ",
      "    This class provides common functionality for all models.",
      "    \"\"\"",
      "    @declared_attr",
      "    def __tablename__(cls) -> str:",
      "        \"\"\"",
      "        Generate the table name from the class name.",
      "        ",
      "        Returns:",
      "            str: The table name",
      "        \"\"\"",
      "        return cls.__name__.lower()",
      "",
      "    # Common columns for all models",
      "    created_at = Column(DateTime, default=datetime.now, nullable=False)",
      "    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, nullable=False)"
    ],
    "description": "SQLAlchemy Base Model"
  },
  "SQLAlchemy Model": {
    "prefix": "sqlalchemy-model",
    "body": [
      "from sqlalchemy import Boolean, Column, String, DateTime, Integer, ForeignKey",
      "from sqlalchemy.orm import relationship",
      "from datetime import datetime",
      "",
      "from .base import Base, generate_uuid",
      "",
      "class ${0}(Base):",
      "    __tablename__ = \"${0}\"",
      "",
      "    id = Column(String, primary_key=True, default=generate_uuid)",
      "    email = Column(String, unique=True, index=True, nullable=False)",
      "    hashed_password = Column(String, nullable=False)",
      "    tenant_id = Column(String, ForeignKey(\"tenants.id\"), nullable=False)",
      "",
      "    tenant = relationship(\"Tenant\", back_populates=\"users\")"
    ],
    "description": "SQLAlchemy Model"
  }
}
